package org.drooms.strategy.random.nonsuicidal;

import org.slf4j.Logger;
import org.drooms.impl.logic.facts.Positioned;
import org.drooms.impl.logic.facts.CurrentPlayer;
import java.util.Random;
import java.util.ArrayList;
import org.drooms.api.Move;

global Logger logger;

declare entry-point rewardEvents
    @doc("A stream of reward events generated by the game")
end

declare entry-point gameEvents
    @doc("A stream of non-reward events generated by the game")
end

declare entry-point playerEvents
    @doc("A stream of events generated by players")
end

rule "Determine whether a position to the left is available to be moved into"
when
    CurrentPlayer($x: x, $y: y)
    not Positioned(x == ($x - 1), y == $y)
then
    logger.debug("LEFT move is available.");
    insertLogical (
        Move.LEFT
    );
end

rule "Determine whether a position to the right is available to be moved into"
when
    CurrentPlayer($x: x, $y: y)
    not Positioned(x == ($x + 1), y == $y)
then
    logger.debug("RIGHT move is available.");
    insertLogical (
        Move.RIGHT
    );
end

rule "Determine whether a position to the top is available to be moved into"
when
    CurrentPlayer($x: x, $y: y)
    not Positioned(x == $x, y == ($y + 1))
then
    logger.debug("UP move is available.");
    insertLogical (
        Move.UP
    );
end

rule "Determine whether a position to the bottom is available to be moved into"
when
    CurrentPlayer($x: x, $y: y)
    not Positioned(x == $x, y == ($y - 1))
then
    logger.debug("DOWN move is available.");
    insertLogical (
        Move.DOWN
    );
end

rule "Pick one of the available moves at random"
salience -10
when
    $moves : ArrayList( size > 0 ) from collect( Move() )
then
    int size = $moves.size();
    Random random = new Random(System.nanoTime());
    channels["decision"].send($moves.get(random.nextInt(size)));
end